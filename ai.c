/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Program Name: Gatherers (C)                                                                                            //
//  Author: Jeffrey Bednar                                                                                                 //
//  Copyright: Illusion Interactive, 2011                                                                                  //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _AI_C_
#define _AI_C_
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "main.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ENTITY* __cdecl AI_FindClosest(ENTITY* p_Inquirer, int iType, GLOBALS* p_Globals) {
    ENTITY* p_Closest = NULL;
    ENTITY* p_Current = (*p_Globals).p_RootEntity;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Map size has changed to 5750 x 5750. The maximum search zone needs to increase.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    float fClosestDistance = 9000.0f;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    while(p_Current) {
        if((*p_Current).iType == iType && (*p_Current).bIsAlive) {
            float fDistance = sqrt(
                pow((*p_Inquirer).CenterPoint.fX - (*p_Current).CenterPoint.fX, 2.0f) +
                pow((*p_Inquirer).CenterPoint.fY - (*p_Current).CenterPoint.fY, 2.0f)
            );
            if(fDistance < fClosestDistance) {
                fClosestDistance = fDistance;
                p_Closest = p_Current;
            }
        }
        p_Current = (ENTITY*)(*p_Current).p_Next;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Returns null if no entities of a specific type were found.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return p_Closest;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl AI_HandleWorkers(ENTITY* p_Worker, GLOBALS* p_Globals) {
    if((*p_Worker).bIsCarrying) {
        ENTITY* p_ComCenter = AI_FindClosest(p_Worker, ENTITY_COMMAND, p_Globals);
        if(p_ComCenter) {
            if(ENTITY_CollidedWith(p_Worker, p_ComCenter)) {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // The worker is carrying minerals.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                if((*p_Worker).iMineralCount > 0) {
                    int iMessageStyle = MESSAGE_GAIN_MINERALS;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // For fun, have a chance to get a golden mineral.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    if(MISC_RandomNumber(1, 5) >= 5) {
                        (*p_Worker).iMineralCount += MISC_RandomNumber(1, (*p_Worker).iMineralCount << MINERALS_MULTIPLIER);
                        iMessageStyle = MESSAGE_BONUS_MINERALS;
                    }
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    sprintf((*p_Globals).szBuffer, "%d", (*p_Worker).iMineralCount);
                    MESSAGE_Create((*p_Globals).szBuffer, (*p_Worker).CenterPoint, iMessageStyle, p_Globals);
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    (*p_Globals).iMineralCount += (*p_Worker).iMineralCount;
                    (*p_ComCenter).iMineralCount += (*p_Worker).iMineralCount;
                    (*p_Worker).iMineralCount = 0;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Keep them there for a period of time.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ENTITY_Pause(p_Worker, MINERALS_COMMAND_PAUSE);
                    ENTITY_Pause(p_ComCenter, MINERALS_COMMAND_PAUSE);
                }
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // The worker is carrying gas.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                if((*p_Worker).iGasCount > 0) {
                    int iMessageStyle = MESSAGE_GAIN_GAS;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // For fun, have a chance to get a golden gas bottle.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    if(MISC_RandomNumber(1, 5) >= 5) {
                        (*p_Worker).iGasCount += MISC_RandomNumber(1, (*p_Worker).iGasCount << GAS_MULTIPLIER);
                        iMessageStyle = MESSAGE_BONUS_GAS;
                    }
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    sprintf((*p_Globals).szBuffer, "%d", (*p_Worker).iGasCount);
                    MESSAGE_Create((*p_Globals).szBuffer, (*p_Worker).CenterPoint, iMessageStyle, p_Globals);
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    (*p_Globals).iGasCount += (*p_Worker).iGasCount;
                    (*p_ComCenter).iGasCount += (*p_Worker).iGasCount;
                    (*p_Worker).iGasCount = 0;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Keep them there for a period of time.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ENTITY_Pause(p_Worker, REFINERY_COMMAND_PAUSE);
                    ENTITY_Pause(p_ComCenter, REFINERY_COMMAND_PAUSE);
                }
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                (*p_Worker).bIsCarrying = 0;
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // Reset the workers movement speed.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                (*p_Worker).MovementSpeed = (FPOINT){WORKER_MOVE_SPEED, WORKER_MOVE_SPEED};
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // Allow the animation engine to draw particular images.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                (*p_ComCenter).iState = ANIMATE_COMMAND_RECEIVE;
                (*p_Worker).iState = ANIMATE_WORKER_NORMAL;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // The worker has NOT collided with the command center.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else {
                ENTITY_MoveTo(p_Worker, p_ComCenter, p_Globals);
            }
        }
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // This worker is not carrying minerals right now.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    else {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // True, if the worker has collided with what it was operating on.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if(ENTITY_CollidedWith(p_Worker, (ENTITY*)(*p_Worker).p_Operating)) {
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // What resource did I collide with?
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            switch((*(ENTITY*)(*p_Worker).p_Operating).iType) {
                case ENTITY_MINERAL: {
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // True, if there is enough minerals to grab.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    if((*(ENTITY*)(*p_Worker).p_Operating).iMineralCount >= MINERALS_PER_GRAB) {
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        // Add minerals grabbed to specific entities.
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        (*(ENTITY*)(*p_Worker).p_Operating).iMineralCount -= MINERALS_PER_GRAB;
                        (*p_Worker).iMineralCount += MINERALS_PER_GRAB;
                        (*p_Worker).bIsCarrying = 1;
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        // Slow the workers movement speed.
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        (*p_Worker).MovementSpeed = 
                            (FPOINT) {
                                WORKER_MOVE_SPEED / WORKER_MINERAL_DIVISOR, 
                                WORKER_MOVE_SPEED / WORKER_MINERAL_DIVISOR
                        };
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        // Allow the animation engine to draw particular images.
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        (*p_Worker).iState = ANIMATE_WORKER_MINERALS;
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        // Keep them there for a period of time.
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        ENTITY_Pause(p_Worker, MINERALS_PAUSE);
                        ENTITY_Pause((ENTITY*)(*p_Worker).p_Operating, MINERALS_PAUSE);
                    }
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // There was NOT enough minerals to grab.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    else {
                        ENTITY_DeleteSpecific((ENTITY*)(*p_Worker).p_Operating, p_Globals);
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        // Instead of sitting around doing nothing, find them another field to harvest.
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        ENTITY* p_MinField = AI_FindClosest(p_Worker, ENTITY_MINERAL, p_Globals);
                        if(p_MinField) {
                            (*p_Worker).p_Operating = (struct ENTITY*)p_MinField;
                        }
                        else {
                            (*p_Worker).p_Operating = NULL;
                        }
                    }
                    break;
                }
                case ENTITY_REFINERY: {
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // True, if there is enough gas to grab.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    if((*(ENTITY*)(*p_Worker).p_Operating).iGasCount >= GAS_PER_GRAB) {
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        // Add gas grabbed to specific entities.
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        (*(ENTITY*)(*p_Worker).p_Operating).iGasCount -= GAS_PER_GRAB;
                        (*p_Worker).iGasCount += GAS_PER_GRAB;
                        (*p_Worker).bIsCarrying = 1;
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        // Slow the workers movement speed.
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        (*p_Worker).MovementSpeed = 
                            (FPOINT) {
                                WORKER_MOVE_SPEED / WORKER_GAS_DIVISOR, 
                                WORKER_MOVE_SPEED / WORKER_GAS_DIVISOR
                        };
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        // Allow the animation engine to draw particular images.
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        (*p_Worker).iState = ANIMATE_WORKER_GAS;
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        // Keep them there for a period of time.
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        ENTITY_Pause(p_Worker, REFINERY_PAUSE);
                        ENTITY_Pause((ENTITY*)(*p_Worker).p_Operating, REFINERY_PAUSE);
                    }
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // There was NOT enough gas to grab.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    else {
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        // Instead of sitting around doing nothing, find them another field to harvest.
                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                        ENTITY* p_Refinery = AI_FindClosest(p_Worker, ENTITY_REFINERY, p_Globals);
                        if(p_Refinery) {
                            (*p_Worker).p_Operating = (struct ENTITY*)p_Refinery;
                        }
                        else {
                            (*p_Worker).p_Operating = NULL;
                        }
                    }
                }
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The worker has NOT collided with what it was operating on.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        else {
            ENTITY_MoveTo(p_Worker, (ENTITY*)(*p_Worker).p_Operating, p_Globals);
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
