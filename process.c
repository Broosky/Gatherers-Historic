/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Program Name: Gatherers (C)                                                                                            //
//  Author: Jeffrey Bednar                                                                                                 //
//  Copyright: Illusion Interactive, 2011                                                                                  //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _PROCESS_C_
#define _PROCESS_C_
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "main.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Main simulation processing. All operations are centralized in this one, timed, function.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PROC_ProcessScene(DBLBUF* p_DblBuf, GLOBALS* p_Globals, IMAGES* p_Images, CARD* p_Card) {
    TIMEBASE* p_Timer = TIMEBASE_Create(0.0f, p_Globals);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    PROC_ApplyTranslations(p_DblBuf, p_Globals, p_Images);
    PROC_DrawBackground(p_DblBuf, p_Globals, p_Images);
    PROC_UpdateAnimation(p_Globals);
    PROC_ProcessEntities(p_DblBuf, p_Globals, p_Images);
    PROC_DrawSelectionArea(p_DblBuf, p_Globals, RGB(0, 255, 0));
    PROC_DrawBuildType(p_DblBuf, p_Globals, p_Images);
    PROC_ProcessMessages(p_DblBuf, p_Globals, p_Images);
    CARD_EvaluateSelected(p_Card, p_Globals, p_Images);
    PROC_DrawHUD(p_DblBuf, p_Globals, p_Images, p_Card);
    PROC_DrawDiagnostics(p_DblBuf, p_Globals, p_Images);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DBLBUF_Flip(p_DblBuf);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    (*p_Globals).fProcessTime = TIMEBASE_EndTimer(p_Timer);
    (*p_Globals).fProcessTimeSum += (*p_Globals).fProcessTime;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    TIMEBASE_Kill(p_Timer, p_Globals);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Future:
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// - Put frequently used variables that are accessed via dereferencing onto the stack.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PROC_DrawSelectionArea(DBLBUF* p_DblBuf, GLOBALS* p_Globals, COLORREF PenColour) {
    if((*p_Globals).bDrawSelectionRect && !(*p_Globals).bCreate) {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        HPEN hPen = CreatePen(PS_SOLID, 1, PenColour);
        HGDIOBJ hPenTemp = SelectObject((*p_DblBuf).hDCMem, hPen);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        IPOINT OldMousePosition = {(*p_Globals).iOldMouseX, (*p_Globals).iOldMouseY};
        IPOINT CurrentMousePosition = {(*p_Globals).iMouseX, (*p_Globals).iMouseY};
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Top, right, bottom, left.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        MoveToEx((*p_DblBuf).hDCMem, OldMousePosition.iX, OldMousePosition.iY, NULL);
        LineTo((*p_DblBuf).hDCMem, CurrentMousePosition.iX, OldMousePosition.iY);
        MoveToEx((*p_DblBuf).hDCMem, CurrentMousePosition.iX, OldMousePosition.iY, NULL);
        LineTo((*p_DblBuf).hDCMem, CurrentMousePosition.iX, CurrentMousePosition.iY);
        MoveToEx((*p_DblBuf).hDCMem, CurrentMousePosition.iX, CurrentMousePosition.iY, NULL);
        LineTo((*p_DblBuf).hDCMem, OldMousePosition.iX, CurrentMousePosition.iY);
        MoveToEx((*p_DblBuf).hDCMem, OldMousePosition.iX, CurrentMousePosition.iY, NULL);
        LineTo((*p_DblBuf).hDCMem, OldMousePosition.iX, OldMousePosition.iY);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        SelectObject((*p_DblBuf).hDCMem, hPenTemp);
        DeleteObject(hPen);
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Future:
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// - Put frequently used variables that are accessed via dereferencing onto the stack.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PROC_ApplyTranslations(DBLBUF* p_DblBuf, GLOBALS* p_Globals, IMAGES* p_Images) {
    if((*p_Globals).bEnableTranslations) {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        float fAmount = 25.0f;
        float fLateralTranslation = 0.0f;
        float fVerticalTranslation = 0.0f;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Top left.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if((*p_Globals).iMouseX <= (*p_Globals).iThreshold && (*p_Globals).iMouseY <= (*p_Globals).iThreshold) {
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Allow lateral translation.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if((*p_Globals).fLateralTranslation < 0.0f) {
                fLateralTranslation = fAmount;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // We translated past a boundary. Reset the translation with the difference.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else {
                fLateralTranslation = -(*p_Globals).fLateralTranslation;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Allow vertical translation.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if((*p_Globals).fVerticalTranslation < 0.0f) {
                fVerticalTranslation = fAmount;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // We translated past a boundary. Reset the translation with the difference.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else {
                fVerticalTranslation = -(*p_Globals).fVerticalTranslation;
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Bottom left.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        else if(
            (*p_Globals).iMouseX <= (*p_Globals).iThreshold &&
            (*p_Globals).iMouseY >= (*p_DblBuf).ClientArea.bottom - (*p_Globals).iThreshold
        ) {
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Allow lateral translation.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if((*p_Globals).fLateralTranslation < 0.0f) {
                fLateralTranslation = fAmount;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // We translated past a boundary. Reset the translation with the difference.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else {
                fLateralTranslation = -(*p_Globals).fLateralTranslation;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Allow vertical translation.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if(
                (*p_Globals).fVerticalTranslation >
                -((*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmHeight - (*p_DblBuf).ClientArea.bottom)
            ) {
                fVerticalTranslation = -fAmount;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // We translated past a boundary. Reset the translation with the difference.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else {
                fVerticalTranslation = 0.0f - (
                    (*p_Globals).fVerticalTranslation +
                    ((*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmHeight - (*p_DblBuf).ClientArea.bottom)
                );
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Bottom right.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        else if(
            (*p_Globals).iMouseX >= (*p_DblBuf).ClientArea.right - (*p_Globals).iThreshold &&
            (*p_Globals).iMouseY >= (*p_DblBuf).ClientArea.bottom - (*p_Globals).iThreshold
        ) {
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Allow lateral translation.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if(
                (*p_Globals).fLateralTranslation >
                -((*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmWidth - (*p_DblBuf).ClientArea.right)
            ) {
                fLateralTranslation = -fAmount;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // We translated past a boundary. Reset the translation with the difference.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else {
                fLateralTranslation = 0.0f - (
                    (*p_Globals).fLateralTranslation +
                    ((*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmWidth - (*p_DblBuf).ClientArea.right)
                );
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Allow vertical translation.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if(
                (*p_Globals).fVerticalTranslation >
                -((*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmHeight - (*p_DblBuf).ClientArea.bottom)
            ) {
                fVerticalTranslation = -fAmount;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // We translated past a boundary. Reset the translation with the difference.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else {
                fVerticalTranslation = 0.0f - (
                    (*p_Globals).fVerticalTranslation +
                    ((*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmHeight - (*p_DblBuf).ClientArea.bottom)
                );
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Top right.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        else if(
            (*p_Globals).iMouseX >= (*p_DblBuf).ClientArea.right - (*p_Globals).iThreshold &&
            (*p_Globals).iMouseY <= (*p_Globals).iThreshold
        ) {
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Allow lateral translation.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if(
                (*p_Globals).fLateralTranslation >
                -((*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmWidth - (*p_DblBuf).ClientArea.right)
            ) {
                fLateralTranslation = -fAmount;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // We translated past a boundary. Reset the translation with the difference.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else {
                fLateralTranslation = 0.0f - (
                    (*p_Globals).fLateralTranslation +
                    ((*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmWidth - (*p_DblBuf).ClientArea.right)
                );
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Allow vertical translation.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if((*p_Globals).fVerticalTranslation < 0.0f) {
                fVerticalTranslation = fAmount;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // We translated past a boundary. Reset the translation with the difference.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else {
                fVerticalTranslation = -(*p_Globals).fVerticalTranslation;
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Left.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        else if((*p_Globals).iMouseX <= (*p_Globals).iThreshold) {
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Allow translation.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if((*p_Globals).fLateralTranslation < 0.0f) {
                fLateralTranslation = fAmount;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // We translated past a boundary. Reset the translation with the difference.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else {
                fLateralTranslation = -(*p_Globals).fLateralTranslation;
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Bottom.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        else if((*p_Globals).iMouseY >= (*p_DblBuf).ClientArea.bottom - (*p_Globals).iThreshold) {
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Allow translation.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if(
                (*p_Globals).fVerticalTranslation >
                -((*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmHeight - (*p_DblBuf).ClientArea.bottom)
            ) {
                fVerticalTranslation = -fAmount;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // We translated past a boundary. Reset the translation with the difference.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else {
                fVerticalTranslation = 0.0f - (
                    (*p_Globals).fVerticalTranslation +
                    ((*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmHeight - (*p_DblBuf).ClientArea.bottom)
                );
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Right.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        else if((*p_Globals).iMouseX >= (*p_DblBuf).ClientArea.right - (*p_Globals).iThreshold) {
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Allow translation.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if(
                (*p_Globals).fLateralTranslation >
                -((*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmWidth - (*p_DblBuf).ClientArea.right)
            ) {
                fLateralTranslation = -fAmount;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // We translated past a boundary. Reset the translation with the difference.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else {
                fLateralTranslation = 0.0f - (
                    (*p_Globals).fLateralTranslation +
                    ((*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmWidth - (*p_DblBuf).ClientArea.right)
                );
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Top.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        else if((*p_Globals).iMouseY <= (*p_Globals).iThreshold) {
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Allow translation.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if((*p_Globals).fVerticalTranslation < 0.0f) {
                fVerticalTranslation = fAmount;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // We translated past a boundary. Reset the translation with the difference.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else {
                fVerticalTranslation = -(*p_Globals).fVerticalTranslation;
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Accumulate translations.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (*p_Globals).fLateralTranslation += fLateralTranslation;
        (*p_Globals).fVerticalTranslation += fVerticalTranslation;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Apply translations.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (*p_Images).Terrain[(*p_Globals).iMapIndex].Location.fX += fLateralTranslation;
        (*p_Images).Terrain[(*p_Globals).iMapIndex].Location.fY += fVerticalTranslation;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Incase we are selecting entities (via mouse drag) and we enter the translation border.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (*p_Globals).iOldMouseX += fLateralTranslation;
        (*p_Globals).iOldMouseY += fVerticalTranslation;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ENTITY* p_Entity = (*p_Globals).p_RootEntity;
        while(p_Entity) {
            (*p_Entity).Location.fX += fLateralTranslation;
            (*p_Entity).Location.fY += fVerticalTranslation;
            (*p_Entity).CenterPoint.fX += fLateralTranslation;
            (*p_Entity).CenterPoint.fY += fVerticalTranslation;
            (*p_Entity).MinorDestinationCenterPoint.fX += fLateralTranslation;
            (*p_Entity).MinorDestinationCenterPoint.fY += fVerticalTranslation;
            (*p_Entity).MajorDestinationCenterPoint.fX += fLateralTranslation;
            (*p_Entity).MajorDestinationCenterPoint.fY += fVerticalTranslation;
            p_Entity = (ENTITY*)(*p_Entity).p_Next;
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        MESSAGE* p_Message = (*p_Globals).p_RootMessage;
        while(p_Message) {
            (*p_Message).Location.fX += fLateralTranslation;
            (*p_Message).Location.fY += fVerticalTranslation;
            p_Message = (MESSAGE*)(*p_Message).p_Next;
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PROC_UpdateAnimation(GLOBALS* p_Globals) {
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // This function determines if the picture of all the entities needs to be updated.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    (*p_Globals).iAnimateCount++;
    if((*p_Globals).iAnimateCount >= (*p_Globals).fAnimationTick) {
        (*p_Globals).bAnimate = 1;
        (*p_Globals).iAnimateCount = 0;
    }
    else {
        (*p_Globals).bAnimate = 0;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PROC_DrawBackground(DBLBUF* p_DblBuf, GLOBALS* p_Globals, IMAGES* p_Images) {
    DBLBUF_DrawPicture(p_DblBuf, &(*p_Images).Terrain[(*p_Globals).iMapIndex], 0);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PROC_ProcessEntities(DBLBUF* p_DblBuf, GLOBALS* p_Globals, IMAGES* p_Images) {
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ENTITY* p_Current = (*p_Globals).p_RootEntity;
    while(p_Current) {
        (*p_Globals).iEntityCount++;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        switch((*p_Current).iType) {
            case ENTITY_WORKER: {
                if((*p_Globals).bBegin) {
                    if((*p_Current).p_Operating) {
                        AI_HandleWorkers(p_Current, p_Globals);
                    }
                }
                break;
            }
            case ENTITY_MINERAL: {
                break;
            }
            case ENTITY_COMMAND: {
                break;
            }
            case ENTITY_SUPPLY: {
                break;
            }
            case ENTITY_REFINERY: {
                break;
            }
            default: {
                printf("PROC_HandleEntities(): Unknown entity type.\n");
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // This entity is being interacted with.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if((*p_Current).bIsPaused) {
            (*p_Current).fPauseCount += 1.0f;
            if((*p_Current).fPauseCount >= (*p_Current).fPauseTime) {
                (*p_Current).bIsPaused = 0;
                (*p_Current).fPauseCount = 0.0f;
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // The command center is no longer being interacted with.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                switch((*p_Current).iType) {
                    case ENTITY_COMMAND: {
                        (*p_Current).iState = ANIMATE_COMMAND_CREATING;
                        break;
                    }
                    case ENTITY_WORKER: {
                        break;
                    }
                    case ENTITY_MINERAL: {
                        break;
                    }
                    case ENTITY_SUPPLY: {
                        break;
                    }
                    case ENTITY_REFINERY: {
                        break;
                    }
                    default: {
                        printf("PROC_HandleEntities(): Unknown entity type.\n");
                    }
                }
            }
        }
        else {
            if((*p_Current).bIsInMotion) {
                ENTITY_UpdatePosition(p_Current, p_Globals);
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Only render the entity, or information about the entity, if it's in the viewport.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if(
            (*p_Current).CenterPoint.fX >= 0.0f &&
            (*p_Current).CenterPoint.fY >= 0.0f &&
            (*p_Current).CenterPoint.fX <= (*p_DblBuf).ClientArea.right &&
            (*p_Current).CenterPoint.fY <= (*p_DblBuf).ClientArea.bottom
        ) {
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if((*p_Globals).bDrawStatuses) {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                if((*p_Current).bIsPaused) {
                    DBLBUF_DrawEntityEllipse(p_DblBuf, p_Current, RGB(255, 255, 255), RGB(100, 0, 0));
                }
                else if(!(*p_Current).bIsAlive) {
                    DBLBUF_DrawEntityEllipse(p_DblBuf, p_Current, RGB(255, 255, 255), RGB(0, 100, 0));
                }
                else if(!(*p_Current).p_Next) {
                    DBLBUF_DrawEntityEllipse(p_DblBuf, p_Current, RGB(255, 255, 255), RGB(0, 0, 100));
                }
                else if(p_Current == (*p_Globals).p_RootEntity) {
                    DBLBUF_DrawEntityEllipse(p_DblBuf, p_Current, RGB(255, 255, 255), RGB(100, 100, 0));
                }
                else if((*p_Current).bIsCarrying) {
                    DBLBUF_DrawEntityEllipse(p_DblBuf, p_Current, RGB(255, 255, 255), RGB(0, 100, 100));
                }
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Entity highlighting has priority, with regards to statuses.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if(ENTITY_WithinPoint(p_Current, (FPOINT){(*p_Globals).iMouseX, (*p_Globals).iMouseY})) {
                DBLBUF_DrawEntityEllipse(p_DblBuf, p_Current, RGB(255, 255, 255), RGB(100, 0, 100));
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if((*p_Globals).bDrawMinor) {
                DBLBUF_DrawEntityMinorVector(p_DblBuf, p_Current, RGB(255, 127, 255));
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if((*p_Globals).bDrawMajor) {
                DBLBUF_DrawEntityMajorVector(p_DblBuf, p_Current, RGB(0, 255, 127));
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Entity selection has priority.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if((*p_Current).bIsSelected) {
                DBLBUF_DrawEntityEllipse(p_DblBuf, p_Current, RGB(255, 255, 255), RGB(100, 100, 100));
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if((*p_Globals).bDrawResources) {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // Pink font colour.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                DBLBUF_SetBlitter(p_DblBuf, &((*p_Images).Blitter[8]));
                sprintf((*p_DblBuf).szBlitter, "%d/%dG", (*p_Current).iMineralCount, (*p_Current).iGasCount);
                DBLBUF_Blitter(
                    p_DblBuf,
                    (*p_DblBuf).szBlitter,
                    (FPOINT){(*p_Current).Location.fX, (*p_Current).Location.fY - 20.0f},
                    (*p_Globals).bEnableMasking
                );
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Update the picture.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if((*p_Globals).bAnimate) {
                ENTITY_Animate(p_Current, p_Images);
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            DBLBUF_DrawEntity(p_DblBuf, p_Current, (*p_Globals).bEnableMasking);
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        p_Current = (ENTITY*)(*p_Current).p_Next;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PROC_ProcessMessages(DBLBUF* p_DblBuf, GLOBALS* p_Globals, IMAGES* p_Images) {
    MESSAGE* p_Current = (*p_Globals).p_RootMessage;
    MESSAGE* p_Dead = NULL;
    while(p_Current) {
        (*p_Globals).iMessageCount++;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Only render the message, or information about the message, if it's in the viewport.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if(
            (*p_Current).Location.fX >= 0.0f &&
            (*p_Current).Location.fY >= 0.0f &&
            (*p_Current).Location.fX <= (*p_DblBuf).ClientArea.right &&
            (*p_Current).Location.fY <= (*p_DblBuf).ClientArea.bottom
        ) {
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            switch((*p_Current).iType) {
                case MESSAGE_GAIN_MINERALS: {
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Light blue font colour.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    DBLBUF_SetBlitter(p_DblBuf, &((*p_Images).Blitter[0]));
                    break;
                }
                case MESSAGE_BONUS_MINERALS: {
                    RENDER_ApplyTransform(p_DblBuf, RENDER_SCALE, (*p_Current).fScale, (*p_Current).Location);
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Light blue font colour.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    DBLBUF_SetBlitter(p_DblBuf, &((*p_Images).Blitter[0]));
                    break;
                }
                case MESSAGE_GAIN_GAS: {
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Green font colour.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    DBLBUF_SetBlitter(p_DblBuf, &((*p_Images).Blitter[2]));
                    break;
                }
                case MESSAGE_BONUS_GAS: {
                    RENDER_ApplyTransform(p_DblBuf, RENDER_SCALE, (*p_Current).fScale, (*p_Current).Location);
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Green font colour.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    DBLBUF_SetBlitter(p_DblBuf, &((*p_Images).Blitter[2]));
                    break;
                }
                case MESSAGE_GENERAL_WARNING: {
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Yellow font colour.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    DBLBUF_SetBlitter(p_DblBuf, &((*p_Images).Blitter[6]));
                    break;
                }
                default: {
                    printf("PROC_HandleMessages(): Unknown message type.\n");
                }
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            DBLBUF_Blitter(
                p_DblBuf,
                (*p_Current).szMessage,
                (FPOINT){(*p_Current).Location.fX, (*p_Current).Location.fY},
                (*p_Globals).bEnableMasking
            );
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            RENDER_ResetTransform(p_DblBuf);
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // If this particular call is updating the entity pictures, update the messages as well.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if((*p_Globals).bAnimate) {
            (*p_Current).iLifespan--;
            (*p_Current).Location.fY -= 2.0f;
            (*p_Current).fScale += 0.075f;
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if(!(*p_Current).iLifespan) {
                p_Dead = p_Current;
            }
        }
        if(p_Dead) {
            MESSAGE_DeleteSpecific(p_Dead, p_Globals);
            p_Dead = NULL;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        p_Current = (MESSAGE*)(*p_Current).p_Next;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PROC_DrawDiagnostics(DBLBUF* p_DblBuf, GLOBALS* p_Globals, IMAGES* p_Images) {
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    (*p_Globals).iFrameCount++;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if((*p_Globals).bDiagnostics) {
        (*p_Globals).fClientBottomY = (*p_DblBuf).ClientArea.bottom;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Pink font colour.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        DBLBUF_SetBlitter(p_DblBuf, &((*p_Images).Blitter[8]));
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (*p_Globals).fClientBottomY -= 90.0f;
        sprintf(
            (*p_DblBuf).szBlitter,
            "(%0.2f, %0.2f)",
            (*p_Globals).fLateralTranslation, (*p_Globals).fVerticalTranslation
        );
        DBLBUF_Blitter(
            p_DblBuf,
            (*p_DblBuf).szBlitter,
            (FPOINT){15.0f, (*p_Globals).fClientBottomY},
            (*p_Globals).bEnableMasking
        );
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (*p_Globals).fClientBottomY -= 20.0f;
        sprintf((*p_DblBuf).szBlitter, "(%ld, %ld)", (*p_DblBuf).ClientArea.right, (*p_DblBuf).ClientArea.bottom);
        DBLBUF_Blitter(
            p_DblBuf,
            (*p_DblBuf).szBlitter,
            (FPOINT){15.0f, (*p_Globals).fClientBottomY},
            (*p_Globals).bEnableMasking
        );
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (*p_Globals).fClientBottomY -= 20.0f;
        sprintf((*p_DblBuf).szBlitter, "(%d, %d)", (*p_Globals).iMouseX, (*p_Globals).iMouseY);
        DBLBUF_Blitter(
            p_DblBuf,
            (*p_DblBuf).szBlitter,
            (FPOINT){15.0f, (*p_Globals).fClientBottomY},
            (*p_Globals).bEnableMasking
        );
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (*p_Globals).fClientBottomY -= 20.0f;
        sprintf((*p_DblBuf).szBlitter, "%0.2f ms/s", (*p_Globals).fProcessTimeAverage);
        DBLBUF_Blitter(
            p_DblBuf,
            (*p_DblBuf).szBlitter,
            (FPOINT){15.0f, (*p_Globals).fClientBottomY},
            (*p_Globals).bEnableMasking
        );
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (*p_Globals).fClientBottomY -= 20.0f;
        sprintf((*p_DblBuf).szBlitter, "%0.2f ms", (*p_Globals).fProcessTime * 1000.0f);
        DBLBUF_Blitter(
            p_DblBuf,
            (*p_DblBuf).szBlitter,
            (FPOINT){15.0f, (*p_Globals).fClientBottomY},
            (*p_Globals).bEnableMasking
        );
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (*p_Globals).fClientBottomY -= 20.0f;
        sprintf((*p_DblBuf).szBlitter, "%0.2f", (*p_Globals).fFramesPerSecond);
        DBLBUF_Blitter(
            p_DblBuf,
            (*p_DblBuf).szBlitter,
            (FPOINT){15.0f, (*p_Globals).fClientBottomY},
            (*p_Globals).bEnableMasking
        );
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (*p_Globals).fClientBottomY -= 20.0f;
        sprintf((*p_DblBuf).szBlitter, "%d B", (*p_Globals).iRunningHeap);
        DBLBUF_Blitter(
            p_DblBuf,
            (*p_DblBuf).szBlitter,
            (FPOINT){15.0f, (*p_Globals).fClientBottomY},
            (*p_Globals).bEnableMasking
        );
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (*p_Globals).fClientBottomY -= 20.0f;
        sprintf((*p_DblBuf).szBlitter, "E: %d", (*p_Globals).iEntityCount);
        DBLBUF_Blitter(
            p_DblBuf,
            (*p_DblBuf).szBlitter,
            (FPOINT){15.0f, (*p_Globals).fClientBottomY},
            (*p_Globals).bEnableMasking
        );
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (*p_Globals).fClientBottomY -= 20.0f;
        sprintf((*p_DblBuf).szBlitter, "M: %d", (*p_Globals).iMessageCount);
        DBLBUF_Blitter(
            p_DblBuf,
            (*p_DblBuf).szBlitter,
            (FPOINT){15.0f, (*p_Globals).fClientBottomY},
            (*p_Globals).bEnableMasking
        );
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The counts have already been displayed and were accumulated through different functions. Reset them.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (*p_Globals).iEntityCount = 0;
        (*p_Globals).iMessageCount = 0;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Reset the location that other messages rely on.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (*p_Globals).fClientBottomY = (*p_DblBuf).ClientArea.bottom;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Draw the translation threshold boundaries.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        HPEN hPen = CreatePen(PS_SOLID, 1, RGB(200, 200, 200));
        HGDIOBJ hPenTemp = SelectObject((*p_DblBuf).hDCMem, hPen);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Left, bottom, right, top.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        MoveToEx((*p_DblBuf).hDCMem, (*p_Globals).iThreshold, 0, NULL);
        LineTo((*p_DblBuf).hDCMem, (*p_Globals).iThreshold, (*p_DblBuf).ClientArea.bottom);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        MoveToEx((*p_DblBuf).hDCMem, 0, (*p_DblBuf).ClientArea.bottom - (*p_Globals).iThreshold, NULL);
        LineTo((*p_DblBuf).hDCMem, (*p_DblBuf).ClientArea.right, (*p_DblBuf).ClientArea.bottom - (*p_Globals).iThreshold);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        MoveToEx(
            (*p_DblBuf).hDCMem,
            (*p_DblBuf).ClientArea.right - (*p_Globals).iThreshold,
            (*p_DblBuf).ClientArea.bottom, NULL
        );
        LineTo((*p_DblBuf).hDCMem, (*p_DblBuf).ClientArea.right - (*p_Globals).iThreshold, 0);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        MoveToEx((*p_DblBuf).hDCMem, 0, (*p_Globals).iThreshold, NULL);
        LineTo((*p_DblBuf).hDCMem, (*p_DblBuf).ClientArea.right, (*p_Globals).iThreshold);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        SelectObject((*p_DblBuf).hDCMem, hPenTemp);
        DeleteObject(hPen);
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PROC_DrawResourceBar(DBLBUF* p_DblBuf, GLOBALS* p_Globals, IMAGES* p_Images) {
    (*p_Globals).fClientBottomY = (*p_DblBuf).ClientArea.bottom;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Resources background.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DBLBUF_DrawPictureAt(
        p_DblBuf,
        &(*p_Images).HUD[0],
        (FPOINT){0.0f, (*p_Globals).fClientBottomY - (*p_Images).HUD[0].Bitmap.bmHeight},
        (*p_Globals).bEnableMasking
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Mineral picture.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DBLBUF_DrawPictureAt(
        p_DblBuf,
        &(*p_Images).Mineral[0],
        (FPOINT){20.0f, (*p_Globals).fClientBottomY - 50.0f},
        (*p_Globals).bEnableMasking
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Mineral text with blue font colour.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DBLBUF_SetBlitter(p_DblBuf, &((*p_Images).Blitter[0]));
    sprintf((*p_DblBuf).szBlitter, "%d", (*p_Globals).iMineralCount);
    DBLBUF_Blitter(
        p_DblBuf,
        (*p_DblBuf).szBlitter,
        (FPOINT){60.0f, (*p_Globals).fClientBottomY - 40.0f},
        (*p_Globals).bEnableMasking
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Gas picture.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DBLBUF_DrawPictureAt(
        p_DblBuf,
        &(*p_Images).Gas[0],
        (FPOINT){135.0f, (*p_Globals).fClientBottomY - 50.0f},
        (*p_Globals).bEnableMasking
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Gas text with green font colour.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DBLBUF_SetBlitter(p_DblBuf, &((*p_Images).Blitter[2]));
    sprintf((*p_DblBuf).szBlitter, "%d", (*p_Globals).iGasCount);
    DBLBUF_Blitter(
        p_DblBuf,
        (*p_DblBuf).szBlitter, (FPOINT){175.0f, (*p_Globals).fClientBottomY - 40.0f},
        (*p_Globals).bEnableMasking
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Supply picture.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DBLBUF_DrawPictureAt(
        p_DblBuf,
        &(*p_Images).Worker[0],
        (FPOINT){250.0f, (*p_Globals).fClientBottomY - 43.0f},
        (*p_Globals).bEnableMasking
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Supply text with yellow font colour.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DBLBUF_SetBlitter(p_DblBuf, &((*p_Images).Blitter[6]));
    sprintf(
        (*p_DblBuf).szBlitter,
        "%d/%d (%d)",
        (*p_Globals).iCurrentSupply, (*p_Globals).iTotalSupply, (*p_Globals).iTotalSupply - (*p_Globals).iCurrentSupply
    );
    DBLBUF_Blitter(
        p_DblBuf,
        (*p_DblBuf).szBlitter,
        (FPOINT){280.0f, (*p_Globals).fClientBottomY - 40.0f},
        (*p_Globals).bEnableMasking
    );
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PROC_DrawTaskbar(DBLBUF* p_DblBuf, GLOBALS* p_Globals, IMAGES* p_Images, CARD* p_Card) {
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Taskbar background.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DBLBUF_DrawPictureAt(
        p_DblBuf,
        &(*p_Images).HUD[1],
        (FPOINT){
            (*p_DblBuf).ClientArea.right - (*p_Images).HUD[1].Bitmap.bmWidth - (*p_Images).HUD[1].Bitmap.bmWidth,
            (*p_DblBuf).ClientArea.bottom - (*p_Images).HUD[1].Bitmap.bmHeight
        },
        (*p_Globals).bEnableMasking
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Command card.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DBLBUF_DrawPictureAt(
        p_DblBuf,
        (*p_Card).p_Picture,
        (FPOINT){
            (*p_DblBuf).ClientArea.right - (*p_Images).HUD[1].Bitmap.bmWidth - (*p_Images).HUD[1].Bitmap.bmWidth + 15.0f,
            (*p_DblBuf).ClientArea.bottom - (*p_Images).HUD[1].Bitmap.bmHeight + 15.0f
        },
        (*p_Globals).bEnableMasking
    );
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Future:
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// - Change to FPOINT and IPOINT structures.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PROC_DrawMinimap(DBLBUF* p_DblBuf, GLOBALS* p_Globals, IMAGES* p_Images) {
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Minimap background.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DBLBUF_DrawPictureAt(
        p_DblBuf,
        &(*p_Images).HUD[1],
        (FPOINT){
            (*p_DblBuf).ClientArea.right - (*p_Images).HUD[1].Bitmap.bmWidth,
            (*p_DblBuf).ClientArea.bottom - (*p_Images).HUD[1].Bitmap.bmHeight
        },
        0
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Minimap picture.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FPOINT MinimapOrigin = {
        (*p_DblBuf).ClientArea.right - (*p_Images).HUD[1].Bitmap.bmWidth + 15.0f,
        (*p_DblBuf).ClientArea.bottom - (*p_Images).HUD[1].Bitmap.bmHeight + 15.0f
    };
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DBLBUF_DrawPictureAt(p_DblBuf, &(*p_Images).Minimap[(*p_Globals).iMapIndex], MinimapOrigin, 0);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Render the viewport box.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FPOINT ViewportLocation = {
        (0.0f - (*p_Globals).fLateralTranslation) / (*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmWidth,
        (0.0f - (*p_Globals).fVerticalTranslation) / (*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmHeight
    };
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FPOINT ViewportDelta = {
        (float)(*p_DblBuf).ClientArea.right / (*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmWidth,
        (float)(*p_DblBuf).ClientArea.bottom / (*p_Images).Terrain[(*p_Globals).iMapIndex].Bitmap.bmHeight
    };
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FPOINT MinimapViewportLocation = {MINIMAP_SIZE * ViewportLocation.fX, MINIMAP_SIZE * ViewportLocation.fY};
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FPOINT MinimapViewportDelta = {MINIMAP_SIZE * ViewportDelta.fX, MINIMAP_SIZE * ViewportDelta.fY};
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    HPEN hPen = CreatePen(PS_SOLID, 1, RGB(200, 200, 200));
    HGDIOBJ hPenTemp = SelectObject((*p_DblBuf).hDCMem, hPen);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Top, right, bottom, left.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MoveToEx(
        (*p_DblBuf).hDCMem,
        MinimapOrigin.fX + MinimapViewportLocation.fX,
        MinimapOrigin.fY + MinimapViewportLocation.fY,
        NULL
    );
    LineTo(
        (*p_DblBuf).hDCMem,
        MinimapOrigin.fX + MinimapViewportLocation.fX + MinimapViewportDelta.fX,
        MinimapOrigin.fY + MinimapViewportLocation.fY
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MoveToEx(
        (*p_DblBuf).hDCMem,
        MinimapOrigin.fX + MinimapViewportLocation.fX + MinimapViewportDelta.fX,
        MinimapOrigin.fY + MinimapViewportLocation.fY,
        NULL
    );
    LineTo(
        (*p_DblBuf).hDCMem,
        MinimapOrigin.fX + MinimapViewportLocation.fX + MinimapViewportDelta.fX,
        MinimapOrigin.fY + MinimapViewportLocation.fY + MinimapViewportDelta.fY
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MoveToEx(
        (*p_DblBuf).hDCMem,
        MinimapOrigin.fX + MinimapViewportLocation.fX + MinimapViewportDelta.fX,
        MinimapOrigin.fY + MinimapViewportLocation.fY + MinimapViewportDelta.fY,
        NULL
    );
    LineTo(
        (*p_DblBuf).hDCMem,
        MinimapOrigin.fX + MinimapViewportLocation.fX,
        MinimapOrigin.fY + MinimapViewportLocation.fY + MinimapViewportDelta.fY
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MoveToEx(
        (*p_DblBuf).hDCMem,
        MinimapOrigin.fX + MinimapViewportLocation.fX,
        MinimapOrigin.fY + MinimapViewportLocation.fY + MinimapViewportDelta.fY,
        NULL
    );
    LineTo(
        (*p_DblBuf).hDCMem,
        MinimapOrigin.fX + MinimapViewportLocation.fX,
        MinimapOrigin.fY + MinimapViewportLocation.fY
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    SelectObject((*p_DblBuf).hDCMem, hPenTemp);
    DeleteObject(hPen);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Render the entities.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ENTITY* p_Current = (*p_Globals).p_RootEntity;
    while(p_Current) {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The maps are square, and the locations are a ratio the map size!
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        float fMapSize = 3000.0f;
        FPOINT EntityLocation = {
            ((*p_Current).CenterPoint.fX - (*p_Current).HalfSize.fX - (*p_Globals).fLateralTranslation) / fMapSize,
            ((*p_Current).CenterPoint.fY - (*p_Current).HalfSize.fY - (*p_Globals).fVerticalTranslation) / fMapSize
        };
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FPOINT EntityDelta = {
            ((*p_Current).CenterPoint.fX + (*p_Current).HalfSize.fX - (*p_Globals).fLateralTranslation) / fMapSize,
            ((*p_Current).CenterPoint.fY + (*p_Current).HalfSize.fY - (*p_Globals).fVerticalTranslation) / fMapSize
        };
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FPOINT MinimapEntityLocation = {MINIMAP_SIZE * EntityLocation.fX, MINIMAP_SIZE * EntityLocation.fY};
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FPOINT MinimapEntityDelta = {MINIMAP_SIZE * EntityDelta.fX, MINIMAP_SIZE * EntityDelta.fY};
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        HBRUSH hBrush = NULL;
        HGDIOBJ hBrushTemp = NULL;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        switch((*p_Current).iType) {
            case ENTITY_WORKER: {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                hBrush = CreateSolidBrush(RGB(255, 255, 255));
                hPen = CreatePen(PS_SOLID, 1, RGB(255, 255, 255));
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                hBrushTemp  = SelectObject((*p_DblBuf).hDCMem, hBrush);
                hPenTemp = SelectObject((*p_DblBuf).hDCMem, hPen);
                break;
            }
            case ENTITY_COMMAND: {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                hBrush = CreateSolidBrush(RGB(255, 0, 0));
                hPen = CreatePen(PS_SOLID, 1, RGB(255, 0, 0));
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                hBrushTemp  = SelectObject((*p_DblBuf).hDCMem, hBrush);
                hPenTemp = SelectObject((*p_DblBuf).hDCMem, hPen);
                break;
            }
            case ENTITY_MINERAL: {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                hBrush = CreateSolidBrush(RGB(110, 175, 225));
                hPen = CreatePen(PS_SOLID, 1, RGB(110, 175, 225));
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                hBrushTemp  = SelectObject((*p_DblBuf).hDCMem, hBrush);
                hPenTemp = SelectObject((*p_DblBuf).hDCMem, hPen);
                break;
            }
            case ENTITY_SUPPLY: {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                hBrush = CreateSolidBrush(RGB(255, 255, 0));
                hPen = CreatePen(PS_SOLID, 1, RGB(255, 255, 0));
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                hBrushTemp  = SelectObject((*p_DblBuf).hDCMem, hBrush);
                hPenTemp = SelectObject((*p_DblBuf).hDCMem, hPen);
                break;
            }
            case ENTITY_REFINERY: {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                hBrush = CreateSolidBrush(RGB(0, 255, 0));
                hPen = CreatePen(PS_SOLID, 1, RGB(0, 255, 0));
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                hBrushTemp  = SelectObject((*p_DblBuf).hDCMem, hBrush);
                hPenTemp = SelectObject((*p_DblBuf).hDCMem, hPen);
                break;
            }
            default: {
                printf("PROC_Minimap(): Unknown entity type.\n");
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        Rectangle(
            (*p_DblBuf).hDCMem,
            MinimapOrigin.fX + MinimapEntityLocation.fX,
            MinimapOrigin.fY + MinimapEntityLocation.fY,
            MinimapOrigin.fX + MinimapEntityDelta.fX,
            MinimapOrigin.fY + MinimapEntityDelta.fY
        );
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        SelectObject((*p_DblBuf).hDCMem, hBrushTemp);
        SelectObject((*p_DblBuf).hDCMem, hPenTemp);
        DeleteObject(hBrush);
        DeleteObject(hPen);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        p_Current = (ENTITY*)(*p_Current).p_Next;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PROC_DrawHUD(DBLBUF* p_DblBuf, GLOBALS* p_Globals, IMAGES* p_Images, CARD* p_Card) {
    PROC_DrawResourceBar(p_DblBuf, p_Globals, p_Images);
    PROC_DrawTaskbar(p_DblBuf, p_Globals, p_Images, p_Card);
    PROC_DrawMinimap(p_DblBuf, p_Globals, p_Images);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PROC_DrawBuildLimits(DBLBUF* p_DblBuf, ENTITY* p_Entity, IMAGES* p_Images) {
    HPEN hPen = CreatePen(PS_SOLID, 1, RGB(255, 0, 0));
    HGDIOBJ hPenTemp = SelectObject((*p_DblBuf).hDCMem, hPen);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FPOINT Buffer = {(*p_Images).Worker[0].Bitmap.bmWidth, (*p_Images).Worker[0].Bitmap.bmHeight};
    FPOINT Location = {(*p_Entity).Location.fX, (*p_Entity).Location.fY};
    FPOINT Delta = {(*p_Entity).Size.fX, (*p_Entity).Size.fY};
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Top, right, bottom, left.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MoveToEx((*p_DblBuf).hDCMem, Location.fX - Buffer.fX, Location.fY - Buffer.fY, NULL);
    LineTo((*p_DblBuf).hDCMem, Location.fX + Delta.fX + Buffer.fX, Location.fY - Buffer.fY);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MoveToEx((*p_DblBuf).hDCMem, Location.fX + Delta.fX + Buffer.fX, Location.fY - Buffer.fY, NULL);
    LineTo((*p_DblBuf).hDCMem, Location.fX + Delta.fX + Buffer.fX, Location.fY + Delta.fY + Buffer.fY);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MoveToEx((*p_DblBuf).hDCMem, Location.fX + Delta.fX + Buffer.fX, Location.fY + Delta.fY + Buffer.fY, NULL);
    LineTo((*p_DblBuf).hDCMem, Location.fX - Buffer.fX, Location.fY + Delta.fY + Buffer.fY);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MoveToEx((*p_DblBuf).hDCMem, Location.fX - Buffer.fX, Location.fY + Delta.fY + Buffer.fY, NULL);
    LineTo((*p_DblBuf).hDCMem, Location.fX - Buffer.fX, Location.fY - Buffer.fY);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    SelectObject((*p_DblBuf).hDCMem, hPenTemp);
    DeleteObject(hPen);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PROC_DrawBuildType(DBLBUF* p_DblBuf, GLOBALS* p_Globals, IMAGES* p_Images) {
    if((*p_Globals).bCreate) {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Draw the red barriers that display the build limits for all entities.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ENTITY* p_Current = (*p_Globals).p_RootEntity;
        while(p_Current) {
            PROC_DrawBuildLimits(p_DblBuf, p_Current, p_Images);
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            p_Current = (ENTITY*)(*p_Current).p_Next;
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FPOINT Location = {0.0f, 0.0f};
        FPOINT Delta = {0.0f, 0.0f};
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Draw the buildings image, then the placement restrictions.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        switch((*p_Globals).iBuildType) {
            case ENTITY_COMMAND: {
                Location.fX = (*p_Globals).iMouseX - ((*p_Images).Command[0].Bitmap.bmWidth >> 1);
                Location.fY = (*p_Globals).iMouseY - ((*p_Images).Command[0].Bitmap.bmHeight >> 1);
                Delta.fX = (*p_Images).Command[0].Bitmap.bmWidth;
                Delta.fY = (*p_Images).Command[0].Bitmap.bmHeight;
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                DBLBUF_DrawPictureAt(p_DblBuf, &(*p_Images).Command[0], Location, (*p_Globals).bEnableMasking);
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                break;
            }
            case ENTITY_WORKER: {
                Location.fX = (*p_Globals).iMouseX - ((*p_Images).Worker[0].Bitmap.bmWidth >> 1);
                Location.fY = (*p_Globals).iMouseY - ((*p_Images).Worker[0].Bitmap.bmHeight >> 1);
                Delta.fX = (*p_Images).Worker[0].Bitmap.bmWidth;
                Delta.fY = (*p_Images).Worker[0].Bitmap.bmHeight;
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                DBLBUF_DrawPictureAt(p_DblBuf, &(*p_Images).Worker[0], Location, (*p_Globals).bEnableMasking);
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                break;
            }
            case ENTITY_MINERAL: {
                Location.fX = (*p_Globals).iMouseX - ((*p_Images).Mineral[0].Bitmap.bmWidth >> 1);
                Location.fY = (*p_Globals).iMouseY - ((*p_Images).Mineral[0].Bitmap.bmHeight >> 1);
                Delta.fX = (*p_Images).Mineral[0].Bitmap.bmWidth;
                Delta.fY = (*p_Images).Mineral[0].Bitmap.bmHeight;
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                DBLBUF_DrawPictureAt(p_DblBuf, &(*p_Images).Mineral[0], Location, (*p_Globals).bEnableMasking);
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                break;
            }
            case ENTITY_SUPPLY: {
                Location.fX = (*p_Globals).iMouseX - ((*p_Images).Supply[0].Bitmap.bmWidth >> 1);
                Location.fY = (*p_Globals).iMouseY - ((*p_Images).Supply[0].Bitmap.bmHeight >> 1);
                Delta.fX = (*p_Images).Supply[0].Bitmap.bmWidth;
                Delta.fY = (*p_Images).Supply[0].Bitmap.bmHeight;
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                DBLBUF_DrawPictureAt(p_DblBuf, &(*p_Images).Supply[0], Location, (*p_Globals).bEnableMasking);
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                break;
            }
            case ENTITY_REFINERY: {
                Location.fX = (*p_Globals).iMouseX - ((*p_Images).Refinery[0].Bitmap.bmWidth >> 1);
                Location.fY = (*p_Globals).iMouseY - ((*p_Images).Refinery[0].Bitmap.bmHeight >> 1);
                Delta.fX = (*p_Images).Refinery[0].Bitmap.bmWidth;
                Delta.fY = (*p_Images).Refinery[0].Bitmap.bmHeight;
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                DBLBUF_DrawPictureAt(p_DblBuf, &(*p_Images).Refinery[0], Location, (*p_Globals).bEnableMasking);
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                break;
            }
            default: {
                printf("PROC_DrawBuildType(): Unknown entity type.\n");
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        HPEN hPen = CreatePen(PS_SOLID, 1, RGB(255, 0, 0));
        HGDIOBJ hPenTemp = SelectObject((*p_DblBuf).hDCMem, hPen);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Top, right, bottom, left.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        MoveToEx((*p_DblBuf).hDCMem, Location.fX, Location.fY, NULL);
        LineTo((*p_DblBuf).hDCMem, Location.fX + Delta.fX, Location.fY);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        MoveToEx((*p_DblBuf).hDCMem, Location.fX + Delta.fX, Location.fY, NULL);
        LineTo((*p_DblBuf).hDCMem, Location.fX + Delta.fX, Location.fY + Delta.fY);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        MoveToEx((*p_DblBuf).hDCMem, Location.fX + Delta.fX, Location.fY + Delta.fY, NULL);
        LineTo((*p_DblBuf).hDCMem, Location.fX, Location.fY + Delta.fY);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        MoveToEx((*p_DblBuf).hDCMem, Location.fX, Location.fY + Delta.fY, NULL);
        LineTo((*p_DblBuf).hDCMem, Location.fX, Location.fY);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        SelectObject((*p_DblBuf).hDCMem, hPenTemp);
        DeleteObject(hPen);
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
